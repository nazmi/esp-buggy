<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="light-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EEEN21000: Technical Demo Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeParagraphLink.init()
        </script>
<link rel="icon" href="icon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EEEN21000
   </div>
   <div id="projectbrief">GROUP 30 Line Following Buggy</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_src__d_e_m_o.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Technical Demo Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="journey"></a></p>
<h1><a class="anchor" id="autotoc_md6"></a>
Overview</h1>
<p >We had at least 4 technical demonstrations (TD) for this semester, accessing different parts of the buggy. They emphasise on the hardware control especially the motors and the software solutions on interfacing the microcontroller and other components like sensors and bluetooth module.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
TD1 : Motor Control</h1>
<p >On software side, the key task was getting the encoders and motors working as intended. After testing, I discovered that the distance scaled up with the speed of the motors, which make the distance reading unreliable. So, I settled down on <b>20% duty cycle</b> to keep it steady and avoid any residue momentum after stopping. PWM frequency was set at <b>1000 Hz</b> because the wheels were louder than the switches, why not? The heatsink was also not too hot to touch. I chose to use <b>unipolar mode</b> as this offers less switching losses. </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_1.svg" width="458" height="412"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p >One of the tasks was to make a square of 0.5 m, which I did not know they were so strict about the square. <b>The square had to be in between the wheels</b>.</p>
<p ><em>main.cpp</em> </p><pre class="fragment">Motor  motor(PC_9,PB_8,PC_8,PC_6,PB_9);
Encoder  wheel_left(PC_3,PC_2);
Encoder  wheel_right(PB_14,PB_13);

while(1){

    vector&lt;double&gt; linear {...};
    vector&lt;double&gt; rotation {...};

    for(size_t i=0; i &lt; linear.size(); i++){
        Motor::forward(linear,....);
        Motor::turnright(rotation,...);
    }
}
</pre><p> Above shows a snippet on how I implemented the square sequence. Ideally all values in linear vector are 0.5 m and rotation vector are 90° . However, our vectors looked like this </p><pre class="fragment">vector&lt;double&gt; linear { 0.45, 0.33, 0.33, 0.43};
vector&lt;double&gt; rotation {83, 83, 83, 175};
</pre><p> Note that the last one was more than 90° because the task was to trace the square back! Which was harder when your buggy did not move in straight line. I used bang-bang approach to compensate the tiny deviations between two wheels, implemented in the <a class="el" href="class_motor.html#a3a856b89f959eb1032f8ec2016b29efb" title="Control the motor to cruise forward.">Motor::forward</a>.</p>
<p ><em>motor.cpp</em> </p><pre class="fragment">if ( left_encoder &gt; right_encoder)

    right_motor.write(SLOW_PWM*(correction));
    left_motor.write(SLOW_PWM)

else if ( right_encoder &gt; left_encoder)

    left_motor.write(SLOW_PWM*(correction));
    right_motor.write(SLOW_PWM)
</pre><p >Correction is evaluated by ratio of bigger encoder number to smaller encoder number, giving percentage around 110%.</p>
<p >We have received full marks on TD1. This promises us a good start in our journey in producing a winning buggy.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
TD2 : Sensors</h1>
<p >This is where we have to interface sensors and bluetooth module with the microcontroller. The bluetooth part is easily done by connecting to correct RX, TX terminal. In this case I used <b>BufferedSerial</b> to handle the communication between F401RE and HM-10. Sensors are the tricky bit, since we chose not to arrange it in a one row but two instead. However, I will discuss on general process of configuration and calibration without considering the arrangement.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_2.svg" width="334" height="244"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p >It is easier manage 6 sensors if they are connected to op-amp, this approach allows calibration only using potetiometer instead of software. Since this is not available to us, we need to calibrate black and white level of the sensors.</p>
<ol type="1">
<li><p class="startli">The <b>white level</b> can be calibrated by placing <b>white card</b> under the sensor and turning the sensor under <b>normal condition at fixed height from the sensors</b>. <em>Does VDD matter?</em> No, because reading is normalised,you can do whatever scaling you want as long as you understand. Here, I choose maximum level of <b>10</b>.</p>
<p class="startli">Recall that I have <em>raw uncalibrated data (white level)</em> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Sensor 1   </th><th class="markdownTableHeadNone">Sensor 2   </th><th class="markdownTableHeadNone">Sensor 3   </th><th class="markdownTableHeadNone">Sensor 4   </th><th class="markdownTableHeadNone">Sensor 5   </th><th class="markdownTableHeadNone">Sensor 6    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6.326   </td><td class="markdownTableBodyNone">7.234   </td><td class="markdownTableBodyNone">6.107   </td><td class="markdownTableBodyNone">6.565   </td><td class="markdownTableBodyNone">6.122   </td><td class="markdownTableBodyNone">4.921   </td></tr>
</table>
<p class="startli">How big is the scale factor to make it <b>10</b>? </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Sensor 1   </th><th class="markdownTableHeadNone">Sensor 2   </th><th class="markdownTableHeadNone">Sensor 3   </th><th class="markdownTableHeadNone">Sensor 4   </th><th class="markdownTableHeadNone">Sensor 5   </th><th class="markdownTableHeadNone">Sensor 6    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.580   </td><td class="markdownTableBodyNone">1.382   </td><td class="markdownTableBodyNone">1.637   </td><td class="markdownTableBodyNone">1.523   </td><td class="markdownTableBodyNone">1.633   </td><td class="markdownTableBodyNone">2.032   </td></tr>
</table>
<p class="startli">Now, just apply a scale factor to each sensor to scale it to desired maximum level </p><dl class="section note"><dt>Note</dt><dd>We have assume the sensors scale linearly. <em>But does it?</em></dd></dl>
</li>
<li>Next, the <b>black level</b> can be calibrated by placing <b>black track</b> under the sensor and turning the sensor under <b>minimum light condition</b>. This ensures we get minimum treshold value at minimum external noise(infrared). <em>What to do with black level?</em> It is pretty much pointless to read small values that is not useful to distance calculation, so black level is the treshold of the sensor reading.</li>
<li><p class="startli">Although we expect perfect results by calibration, there are always external noise coming from sunlight and other sources. This issue needed to be addressed to avoid unreliable readings consist of random errors.</p>
<p class="startli">\( reading_i = noise_i + emitter_i \quad \quad where \quad reading_i &gt; treshold_i \)</p>
<dl class="section note"><dt>Note</dt><dd>Noise is simply background reading when none of the emitter is turn off.</dd></dl>
<p>Measurements of the analog input when all emitter is off at the start of each read is very easy to implement. When this is done correctly, we will get the best intended readings from the sensor.</p>
</li>
</ol>
<p ><details>
<summary>more...</summary> Showcase some of the tests done to calibrate the sensors.<br  />
 </p><div align="center"> <img src="white.svg" alt="White Level" style="pointer-events: none;" class="inline"/> White level raw<br  />
<br  />
 <img src="black.svg" alt="Black Level" style="pointer-events: none;" class="inline"/> Black level raw<br  />
<br  />
 <img src="distance.svg" alt="Variation of distance" style="pointer-events: none;" class="inline"/> Sweeping the white card back and forth to the sensor. </div><p> </details>
</p>
<p >This part is where I realised how important scaling factor impact the results. If all readings normalised to 10, distance calculation is simplified because of the linear properties we see before. From the sensor array, if we establish a coordinate system with its axis between sensor 3 and 4, we can assign weight for each sensor like in the example below.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_3.svg" width="462" height="102"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Sensor 1   </th><th class="markdownTableHeadNone">Sensor 2   </th><th class="markdownTableHeadNone">Sensor 3   </th><th class="markdownTableHeadNone">Sensor 4   </th><th class="markdownTableHeadNone">Sensor 5   </th><th class="markdownTableHeadNone">Sensor 6    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-30   </td><td class="markdownTableBodyNone">-20   </td><td class="markdownTableBodyNone">-10   </td><td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">20   </td><td class="markdownTableBodyNone">30   </td></tr>
</table>
<p >which can be reduced to \(\ distance = \sum_{1}^{6} reading_i \times weight_i \) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
