<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="light-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EEEN21000: Technical Demo Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.smartmenus/1.0.2/jquery.smartmenus.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
       <script type="text/javascript">
           DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeParagraphLink.init()
        </script>
<link rel="icon" href="icon.ico" type="image/x-icon" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SY2S41MWPX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-SY2S41MWPX');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EEEN21000
   </div>
   <div id="projectbrief">GROUP 30 Line Following Buggy</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__d_e_m_o.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Technical Demo Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#overview">Overview</a></li>
<li class="level1"><a href="#motor">TD1: Motor Control</a></li>
<li class="level1"><a href="#sensor">TD2: Sensors</a></li>
<li class="level1"><a href="#steering">TD3: Steering</a></li>
<li class="level1"><a href="#heats">TD4: Heats</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="journey"></a> </p>
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<p >We had at least 4 technical demonstrations (TD) for this semester, accessing different parts of the buggy. They emphasised the hardware control, especially the motors and the software solutions to interface the microcontroller and other components like sensors and Bluetooth module.</p>
<h1><a class="anchor" id="motor"></a>
TD1: Motor Control</h1>
<p >On the software side, the key task was setting up the encoders and motors to work as intended. I settled down on a <b>20% duty cycle</b> to keep it steady and avoid any translational inertia after stopping. PWM frequency set to <b>1000 Hz</b> because the wheels were louder than the switches, why not? The heatsink was also not too hot to touch. I chose to use <b>unipolar mode</b> as this offered fewer switching losses. </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_1.svg" width="458" height="412"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p >The encoder was connected directly to the wheel shaft, and from there we could measure the speed of the rotating wheel. The <a class="el" href="class_q_e_i.html" title="Handle reading pulses from encoder.">QEI</a> library encoded the pulses to <b>X2 resolution</b>, so we need to scale it down to get the actual number of pulses. We also knew the number of pulses per revolution (CPR) was <b>256</b>. </p><p class="formulaDsp">
\begin{align} pulses &amp;= \frac{pulses}{2} \\ rev &amp;= \frac{pulses}{256} \\ distance &amp;= rev \times 2 \pi r \\ velocity &amp;= \frac{distance}{time} \\ \end{align}
</p>
<p >One of the tasks was to make a square of 0.5 m in length. The hardest part was the square had to be in between the wheels. Even worst, I did not tune the task on the actual square at A16. The snippet below shows how I implemented the square sequence.</p>
<p ><em>main.cpp</em></p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_motor.html">Motor</a>  motor(PC_9,PB_8,PC_8,PC_6,PB_9);</div>
<div class="line"><a class="code hl_class" href="class_encoder.html">Encoder</a>  wheel_left(PC_3,PC_2);</div>
<div class="line"><a class="code hl_class" href="class_encoder.html">Encoder</a>  wheel_right(PB_14,PB_13);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>(1){</div>
<div class="line"> </div>
<div class="line">    vector&lt;double&gt; linear {...};</div>
<div class="line">    vector&lt;double&gt; rotation {...};</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i &lt; linear.size(); i++){</div>
<div class="line">        <a class="code hl_function" href="class_motor.html#abbeb0f664d334505276a83b7b7ef77ea">Motor::forward</a>(linear,....);</div>
<div class="line">        <a class="code hl_function" href="class_motor.html#abdec5f02db58b8b0412b7b2c8758339f">Motor::turnright</a>(rotation,...);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_encoder_html"><div class="ttname"><a href="class_encoder.html">Encoder</a></div><div class="ttdoc">Encoder class with helper functions, derived from QEI.</div><div class="ttdef"><b>Definition:</b> encoder.h:28</div></div>
<div class="ttc" id="aclass_motor_html"><div class="ttname"><a href="class_motor.html">Motor</a></div><div class="ttdoc">Motor class to control the motors.</div><div class="ttdef"><b>Definition:</b> motor.h:22</div></div>
<div class="ttc" id="aclass_motor_html_abbeb0f664d334505276a83b7b7ef77ea"><div class="ttname"><a href="class_motor.html#abbeb0f664d334505276a83b7b7ef77ea">Motor::forward</a></div><div class="ttdeci">static void forward(const double distance, Motor *const motor, Encoder *const left_encoder, Encoder *const right_encoder)</div><div class="ttdoc">Control the motor to cruise forward.</div></div>
<div class="ttc" id="aclass_motor_html_abdec5f02db58b8b0412b7b2c8758339f"><div class="ttname"><a href="class_motor.html#abdec5f02db58b8b0412b7b2c8758339f">Motor::turnright</a></div><div class="ttdeci">static void turnright(const double angle, Motor *const motor, Encoder *const left_encoder, Encoder *const right_encoder)</div><div class="ttdoc">Control the motor to turn right.</div></div>
</div><!-- fragment --><p >Ideally all values in linear vector are 0.5 m and rotation vector are 90Â°. However, ours looked like this</p>
<div class="fragment"><div class="line">vector&lt;double&gt; linear { 0.45, 0.33, 0.33, 0.43};</div>
<div class="line">vector&lt;double&gt; rotation {83, 83, 83, 175};</div>
</div><!-- fragment --><p >Note that the last one was more than 90Â° because the task was to trace the square back which was harder when your buggy did not move in a straight line. I used bang-bang control approach to compensate for any tiny deviation between the two wheels, implemented in the <a class="el" href="class_motor.html#abbeb0f664d334505276a83b7b7ef77ea" title="Control the motor to cruise forward.">Motor::forward</a>.</p>
<p ><em>motor.cpp</em></p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( left_encoder &gt; right_encoder)</div>
<div class="line"> </div>
<div class="line">    right_motor.write(<a class="code hl_define" href="motor_8h.html#ae2d5253ae733c15431dbf44cbad409f0">SLOW_PWM</a> * correction);</div>
<div class="line">    left_motor.write(<a class="code hl_define" href="motor_8h.html#ae2d5253ae733c15431dbf44cbad409f0">SLOW_PWM</a>)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> ( right_encoder &gt; left_encoder)</div>
<div class="line"> </div>
<div class="line">    left_motor.write(<a class="code hl_define" href="motor_8h.html#ae2d5253ae733c15431dbf44cbad409f0">SLOW_PWM</a> * correction);</div>
<div class="line">    right_motor.write(<a class="code hl_define" href="motor_8h.html#ae2d5253ae733c15431dbf44cbad409f0">SLOW_PWM</a>)</div>
<div class="ttc" id="amotor_8h_html_ae2d5253ae733c15431dbf44cbad409f0"><div class="ttname"><a href="motor_8h.html#ae2d5253ae733c15431dbf44cbad409f0">SLOW_PWM</a></div><div class="ttdeci">#define SLOW_PWM</div><div class="ttdoc">Slow duty cycle constant.</div><div class="ttdef"><b>Definition:</b> motor.h:14</div></div>
</div><!-- fragment --><p class="formulaDsp">
\begin{align} correction &amp;= \frac{pulse_N}{pulse_M} \ where \ pulse_N &gt; pulse_M \\ \end{align}
</p>
<p> We received full marks on TD1 and this assured us of a good start to our journey in producing a winning buggy.</p>
<h1><a class="anchor" id="sensor"></a>
TD2: Sensors</h1>
<p >This was where we had to interface the sensors and Bluetooth module with the microcontroller. The Bluetooth module was easily configured by connecting to the correct RX, TX pins. In this case, I used <b>BufferedSerial</b> to handle the communication between F401RE and HM-10. Sensors were the tricky bit since we chose not to arrange them in one row but two instead. However, I will discuss on the general process of configuration and calibration without considering our chosen arrangement.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_2.svg" width="334" height="244"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p >It was easier to manage 6 sensors if they are connected to op-amp as this approach allowed calibration only using potentiometer instead of software. Since this was not available to us, we had to calibrate the black and white level of the sensors.</p>
<ol type="1">
<li><p class="startli">The <b>white level</b> was calibrated by placing a <b>white card</b> under the sensors and toggling the sensors under <b>normal conditions at a fixed height from the sensors</b>. <em>Does VDD matter?</em> No, because reading was already normalised, you can do whatever scaling you want as long as you were comfortable with it. Here, I choose a saturation level of <b>10</b>.</p>
<p class="startli">Recall that I had <em>raw uncalibrated data (white level)</em> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">S1   </th><th class="markdownTableHeadNone">S2   </th><th class="markdownTableHeadNone">S3   </th><th class="markdownTableHeadNone">S4   </th><th class="markdownTableHeadNone">S5   </th><th class="markdownTableHeadNone">S6    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3.18998   </td><td class="markdownTableBodyNone">3.26268   </td><td class="markdownTableBodyNone">3.07483   </td><td class="markdownTableBodyNone">3.12763   </td><td class="markdownTableBodyNone">3.22799   </td><td class="markdownTableBodyNone">3.70966   </td></tr>
</table>
<p class="startli">How big is the scale factor to make it <b>10</b>? </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">S1   </th><th class="markdownTableHeadNone">S2   </th><th class="markdownTableHeadNone">S3   </th><th class="markdownTableHeadNone">S4   </th><th class="markdownTableHeadNone">S5   </th><th class="markdownTableHeadNone">S6    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3.13481   </td><td class="markdownTableBodyNone">3.06497   </td><td class="markdownTableBodyNone">3.25221   </td><td class="markdownTableBodyNone">3.19731   </td><td class="markdownTableBodyNone">3.09790   </td><td class="markdownTableBodyNone">2.69567   </td></tr>
</table>
<p class="startli">Now, just apply a scale factor to each sensor to scale it to the desired maximum level. </p><dl class="section note"><dt>Note</dt><dd>We assumed the sensors scaled linearly. <em>But did it?</em></dd></dl>
</li>
<li>The <b>black level</b> was calibrated by placing a <b>black track</b> under the sensors and toggling the sensors under <b>minimum light conditions</b>. This ensured we get minimum treshold value at minimum external noise(infrared). <em>What to do with the black level?</em> It was pretty much pointless to read small values that were not useful for distance calculation, so the black level is the threshold of the sensor activation.</li>
<li><p class="startli">Although we expected perfect results by calibration, there will be always external noise coming from sunlight and other sources. The issue needed to be addressed to avoid unreliable readings consisting of random errors.</p>
<p class="startli">\( reading_i = noise_i + emitter_i \)</p>
<dl class="section note"><dt>Note</dt><dd>Noise is simply background reading when none of the emitters is turned on.</dd></dl>
<p>Measurements of the analogue input when all emitter is off at the start of each read were very easy to implement. When this is done correctly, you get the best-intended readings from the sensor.</p>
</li>
</ol>
<p ><details>
<summary>more...</summary> Showcase some of the tests done to calibrate the sensors.<br  />
 </p><div align="center"> <img src="white.svg" alt="White Level" style="pointer-events: none;" class="inline"/> White level raw<br  />
<br  />
 <img src="black.svg" alt="Black Level" style="pointer-events: none;" class="inline"/> Black level raw<br  />
<br  />
 <img src="distance.svg" alt="Variation of distance" style="pointer-events: none;" class="inline"/> Sweeping the white card back and forth to the sensor. </div><p> </details>
</p>
<p >This part was where I realised how important normalised readings are for distance calculation. If all readings were normalised to a level, the distance formula simply became the weighted mean of sensor readings. From the sensor array, if we established a pivot point between sensors 3 and 4, we could assign a weight for every sensor based on its distance from the pivot as in the example below.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_3.svg" width="462" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_4.svg" width="431" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p >The solution was very simple and the equivalent formula was \(\ distance = \frac{\sum_{1}^{6} reading_i \times weight_i}{\sum_{1}^{6} reading_i} \)</p>
<h1><a class="anchor" id="steering"></a>
TD3: Steering</h1>
<p >When all components were put together, it was time to make sure all can work in sync to follow the white line on the track. The overall look at how the control algorithm work was outlined in the figure below.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_5.svg" width="428" height="564"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p >The first controller scaled the deviations from the white line and outputted target speed for the encoders. Then, a differential was created by using a target value and the output before to create a turning effect for the wheels. This differential then outputs the corresponding PWM outputs for each motor.</p>
<p >Another extra thing I added was adaptive system response based on the position of the line, which manipulate the set point of the left and right controller to create quicker turning response.</p>
<p ><em>wheelcontrol.cpp</em> </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> delta_target = linecontroller.compute();</div>
<div class="line"><span class="keywordtype">float</span> delta_left = m_target - delta_target;</div>
<div class="line"><span class="keywordtype">float</span> delta_right = m_target + delta_target;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (abs_position &lt; 0.5f) {</div>
<div class="line"> </div>
<div class="line">    m_setSetPoint(m_target, m_target);</div>
<div class="line"> </div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abs_position &gt; 15.0f) {</div>
<div class="line"> </div>
<div class="line">    m_setSetPoint(delta_left - 0.4 * delta_target, delta_right + 0.4 * delta_target);</div>
<div class="line"> </div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line"> </div>
<div class="line">    m_setSetPoint(delta_left, delta_right);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p >Other than the control algorithm, I simply added the turnaround code when the BLE signal was sent. The turnaround used the code created in <a class="el" href="md__d_e_m_o.html#motor">TD1</a> with a little tweak to find the centre line instead of rotating 180. This method allows consistent turnaround even when the buggy is not perfectly aligned with the line before the turn.</p>
<h1><a class="anchor" id="heats"></a>
TD4: Heats</h1>
<p >In TD3, we only used proportional gain to drive the buggy. This time we tuned the Kp and Kd gains to anticipate the motion of the buggy. The final Kp and Kd gains were found to be 1.2 and 0.0004 respectively.</p>
<p >In real-world, the derivative term is noisy, so we used a low pass filter to smooth out the noise. The value of alpha in the filter is closer to 1 because we still need the high details of the term to be able to accurately predict the motion of the buggy. The low pass filter was implemented in the following code.</p>
<p ><em>PID.cpp</em> </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> _a = 0.7;</div>
<div class="line"><span class="keywordtype">float</span> error = scaledSP - scaledPV;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Exponential Filter</span></div>
<div class="line"><span class="keywordflow">if</span> (_tauD &gt; 0) {</div>
<div class="line">    dError = _a * error + (1 - _a) * _prevError;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <details>
<summary>more...</summary> Showcase the filter behaviour with different alpha. Simulated error in range [-1,1]<br  />
 </p><div align="center"> <img src="filter.svg" alt="Filter comparison" style="pointer-events: none;" class="inline"/> </div><p> </details>
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
